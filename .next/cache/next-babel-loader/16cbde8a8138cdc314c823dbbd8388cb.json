{"ast":null,"code":"import { formBinderURL, binder } from \"rx-binder\";\nimport { kernels, apiVersion } from \"rx-jupyter\";\nimport * as rxJupyter from \"rx-jupyter\";\nimport * as operators from \"rxjs/operators\";\nimport { tap, map, catchError, filter } from \"rxjs/operators\";\nimport { of } from \"rxjs\";\nexport const UP = \"up\";\nexport const GETTING_UP = \"isitup\";\n\nfunction makeHost({\n  endpoint,\n  token\n}) {\n  return {\n    type: UP,\n    config: {\n      crossDomain: true,\n      endpoint,\n      token\n    }\n  };\n}\n\nexport class LocalForage {\n  set(key, value) {\n    localStorage.setItem(key, JSON.stringify(value));\n  }\n\n  get(key, default_ = null) {\n    return JSON.parse(localStorage.getItem(key) || JSON.stringify(default_));\n  }\n\n}\nconst prefix = \"@BinderKey@\";\nconst myBinderURL = \"https://mybinder.org\";\n\nfunction sleep(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration));\n}\n\nexport class LocalHostStorage {\n  constructor() {\n    this.localForage = new LocalForage();\n    window.addEventListener(\"storage\", this.handleStorageEvent);\n  } //call to clean\n\n\n  close() {\n    window.removeEventListener(\"storage\", this.handleStorageEvent);\n  }\n\n  handleStorageEvent(event) {\n    const {\n      key,\n      newValue\n    } = event; // TODO not implemented\n\n    console.warn(\"Handling storage updates is not implemented. It would be super fantastic to let subscribers know about changes.\");\n\n    if (event.key.startsWith(prefix)) {\n      const binderOpts = JSON.parse(key.slice(prefix.length));\n      console.log(binderOpts);\n      console.log(newValue);\n    }\n  }\n\n  createKey({\n    repo = \"jupyter/notebook\",\n    ref = \"master\",\n    binderURL = myBinderURL\n  }) {\n    return `${prefix}${JSON.stringify({\n      repo,\n      ref,\n      binderURL\n    })}`;\n  }\n\n  async checkUp(host) {\n    if (host.type === GETTING_UP) {\n      return false;\n    }\n\n    return kernels.list(host.config).pipe(map(xhr => {\n      console.log(xhr);\n      return true;\n    }), catchError(err => {\n      console.error(\"error listing kernels on server\", err);\n      return of(false);\n    })).toPromise();\n  }\n\n  async allocate(binderOpts) {\n    let original = this.get(binderOpts);\n\n    if (!original || !original.config) {\n      original = {\n        type: \"isitup\"\n      };\n      this.set(binderOpts, original); // Fall through, don't return as we allocate below\n    } else if (original.type === UP) {\n      // TODO Check if really up\n      const isUp = await this.checkUp(original);\n\n      if (isUp) {\n        return original.config;\n      } // if not up, launch new\n\n    } else if (original.type === GETTING_UP) {\n      // TODO: wait on prior before new one\n      while (!original && original.type !== UP) {\n        await sleep(1000);\n        original = this.get(binderOpts);\n\n        if (original && original.type === UP) {\n          return original.config;\n        }\n      }\n    }\n\n    console.log(\"getting new host\");\n    const host = await binder(binderOpts).pipe(tap(x => {\n      console.log(x);\n    }), filter(msg => msg.phase === \"ready\"), map(msg => makeHost({\n      endpoint: msg.url,\n      token: msg.token\n    }))).toPromise();\n\n    if (!host.config || !host.config.endpoint || !host.config.token || !host.config.crossDomain) {\n      console.error(\"Error\", host);\n      throw new Error(\"Bad host created\");\n    }\n\n    this.set(binderOpts, host);\n    console.log(\"allocated \", host);\n    return host.config;\n  }\n\n  get(opts) {\n    const key = this.createKey(opts);\n    return this.localForage.get(key);\n  }\n\n  set(opts, host) {\n    const key = this.createKey(opts);\n    this.localForage.set(key, host);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}